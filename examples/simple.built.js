!function (context, definition) {
	if (typeof require == 'function' && typeof exports == 'object' && typeof module == 'object') {
		module.exports = definition()
	} else if (typeof define == 'function' && typeof define.amd  == 'object') {
		define(definition)
	} else {
		definition()
	}
}(this, function () {
	var modules = {
	  "/keydispatch/examples/simple.js": "\nvar Presenter = require('presenter').Presenter\n  , keyDispatch = require('../plugin')\n\nvar car = new Presenter('<div id=\"car\" tabIndex=\"1\">5</div>')\nvar view = car.view\nvar v = 10\n\ncar.use(keyDispatch)\n\t.on(function left(e){\n\t\tview.style.left = view.offsetLeft - v + 'px'\n\t})\n\t.on(function right(e){\n\t\tview.style.left = view.offsetLeft + v + 'px'\n\t})\n\t.on('shift + right', function(){\n\t\tview.style.left = view.offsetLeft + v * 5 + 'px'\n\t})\n\t.on('shift + left', function(){\n\t\tview.style.left = view.offsetLeft - v * 5 + 'px'\n\t})\n\t.on('ctrl + alt + super + up', function(){\n\t\tview.style.background = '#bada55'\n\t})\n\t.on('ctrl + alt + super + down', function(){\n\t\tview.style.background = '#55adab'\n\t})\n\ndocument.body.appendChild(view)\nview.focus()\n",
	  "/keydispatch/plugin.js": "\nvar Dispatcher = require('./')\n\nmodule.exports = function(pres){\n\tvar action = new Dispatcher\n\tpres.action('keydown=>keydown', action)\n\tpres.action('keyup=>keyup', action)\n\treturn action\n}",
	  "/presenter/index.js": "module.exports = require('./src')",
	  "/keydispatch/index.js": "\nvar Action = require('action').Action\n  , $then = Action.prototype.then\n  , keys = require('keycode').names\n  , inherit = require('inherit')\n\nvar modifiers = {\n\tctrl: true,\n\talt: true,\n\tshift: true,\n\tsuper: true\n}\n\nmodule.exports = Dispatcher\n\nfunction Dispatcher(){\n\tthis.pins = {}\n}\n\ninherit(Dispatcher, Action)\n\nDispatcher.prototype.keyup = function(e){\n\tvar key = keys[e.which]\n\tif (key in modifiers) this[key] = undefined\n}\n\nDispatcher.prototype.keydown = function(e, subj){\n\te.stopPropagation()\n\tvar key = keys[e.which]\n\tif (!key) return\n\tif (key in modifiers) return this[key] = true\n\tvar pin = this.pins[key]\n\tif (!pin) return\n\n\tactions: for (var i = 0, len = pin.length; i < len; i++) {\n\t\tvar act = pin[i].action\n\t\tfor (var mod in modifiers) {\n\t\t\tif (this[mod] !== act[mod]) continue actions\n\t\t}\n\t\tact.stdin(e, subj)\n\t}\n}\n\nDispatcher.prototype.then = function(pin, action){\n\tif (typeof pin != 'string') action = pin, pin = pin.name\n\tvar mods = pin.split(/ *\\+ */)\n\tpin = mods.pop()\n\taction = $then.call(this, pin, action)\n\tif (mods.length) {\n\t\taction.hasModifiers = true\n\t\tmods.forEach(function(k){\n\t\t\taction[k] = true\n\t\t})\n\t}\n\treturn action\n}\n",
	  "/presenter/src/index.js": "\nvar Base = require('./base')\n  , ChildList = require('./childlist')\n  , Action = require('action').Action\n  , graph = require('graph')\n  , clone = require('clone')\n\nmodule.exports = makePresenter\nmakePresenter.ChildList = ChildList\nmakePresenter.Base = makePresenter.Presenter = Base\n\nvar id = 1\n\n/**\n * Create a Presenter factory\n * \n * If you pass a String as `view` it will be converted to \n * a DOM element. If you pass a function it will be called \n * with `model.toJSON()` to produce a string which gets \n * converted to a DOM element.\n *\n * @param {String} [name]\n * @param {Function|String} template\n * @return {Function}\n */\n\nfunction makePresenter(name, template){\n\tif (arguments.length < 2) {\n\t\ttemplate = name\n\t\tname = 'anon_' + (id++)\n\t}\n\n\t// compile constructor\n\tvar Pres = eval(\n\t\t'(function '+name+'(model){\\n' +\n\t\t'  this.model = model\\n' +\n\t\t(typeof template == 'string' \n\t\t\t? '  Base.call(this, template)'\n\t\t\t: '  Base.call(this, template(model && model.toJSON ? model.toJSON() : model))'\n\t\t) + '\\n' +\n\t\t'  installBehaviour(this, '+name+'.behaviour)\\n' +\n\t\t'  installActions(this, '+name+'.actions)\\n' +\n\t\t'  this.init && this.init.apply(this, arguments)\\n' +\n\t\t'})\\n' +\n\t\t'//@ sourceURL=/compiled/presenters/'+name\n\t)\n\n\tPres.behaviour = []\n\tPres.behave = addBehaviour\n\tPres.actions = {}\n\tPres.action = addAction\n\tPres.use = addPlugin\n\n\t// inherit Base\n\tPres.prototype.__proto__ = Base.prototype\n\n\treturn Pres\n}\n\nfunction addPlugin(plugin){\n\treturn plugin(this)\n}\n\nfunction addAction(hook, action){\n\tif (!action) action = hook, hook = action.name\n\tif (typeof action == 'function') action = new Action(action);\n\t(this.actions[hook] || (this.actions[hook] = [])).push(action)\n\treturn action\n}\n\nfunction installActions(self, actions){\n\tfor (var hook in actions) {\n\t\tvar acts = actions[hook]\n\t\tacts.forEach(function(action){\n\t\t\tself.action(hook, clone(action))\n\t\t})\n\t}\n}\n\nfunction addBehaviour(trigger, action){\n\tif (typeof trigger == 'function') {\n\t\taction = trigger\n\t\ttrigger = trigger.name\n\t}\n\tthis.behaviour.push({\n\t\ttrigger: trigger,\n\t\taction: action\n\t})\n\treturn this\n}\n\nfunction installBehaviour(self, behaviour){\n\tfor (var i = 0, len = behaviour.length; i < len; i++) {\n\t\tvar b = behaviour[i]\n\t\tif (typeof b.action == \"object\") b.action = graph(b.action)\n\t\tself.events.on(b.trigger, b.action)\n\t}\n}\n",
	  "/node_modules/github.com/jkroso/action/tarball/0.1.0/index.js": "\n/**\n * Module dependencies\n */\n\nvar call = Function.prototype.call\n\n/**\n * Action constructor\n * @param {Function|Object} fn\n */\n\nfunction Action(fn){\n\tif (typeof fn == 'function') this.stdin = fn\n\telse for (var f in fn) this[f] = fn[f]\n\tthis.pins = {}\n}\n\n// (string) -> object\nfunction parseConnection(str){\n\tif (typeof str != 'string' || !str) return {from: 'stdout', to: 'stdin'}\n\tstr = str.split('=>')\n\treturn {\n\t\tfrom: str[0],\n\t\tto: str[1] || 'stdin'\n\t}\n}\n\n/**\n * connect `action` to `this` actions `pin`. If you don't\n * provide a `pin` actions name will be used and failing \n * that \"stdout\"\n *\n * @param {String} [pin] \"from=>to\"\n * @param {Function|Action} action\n * @return {Action}\n */\n\nAction.prototype.then = function(pin, action){\n\tif (typeof pin != 'string') action = pin, pin = action.name\n\tvar con = parseConnection(pin)\n\tpin = con.from;\n\t(this.pins[pin] || (this.pins[pin] = [])).push(con)\n\treturn con.action = toAction(action)\n}\n\n/**\n * a chainable `.then()`\n * \n * @param {String} [pin]\n * @param {Function|Action} action\n * @return {this}\n */\n\nAction.prototype.on = function(pin, action){\n\tthis.then(pin, action)\n\treturn this\n}\n\n/**\n * execute actions connected to `pin`. Any extra arguments\n * will be forwarded to the receiving actions\n * \n * @param {String} pin\n * @return {this}\n */\n\nAction.prototype.dispatch = function(pin){\n\tvar cons = this.pins[pin]\n\tif (cons) for (var i = 0, len = cons.length; i < len; i++) {\n\t\tvar con = cons[i]\n\t\tpin = con.action\n\t\tcall.apply(pin[con.to], arguments)\n\t}\n\treturn this\n}\n\n/**\n * create a hard pin on `this` action. hard pins afford nicer \n * syntax and perform better\n * \n * @param {String} name\n * @return {this}\n */\n\nAction.prototype.pin = function(name){\n\tthis[name] = function(){\n\t\tvar cons = this.pins[name], a, c\n\t\tif (!cons) return this\n\t\tfor (var i = 0, len = cons.length; i < len; i++) {\n\t\t\t(a = (c = cons[i]).action)[c.to].apply(a, arguments)\n\t\t}\n\t\treturn this\n\t}\n\treturn this\n}\n\n/**\n * default hard pin\n */\n\nAction.prototype.pin('stdout')\n\n// (Function|Object|Action) -> Action\nfunction toAction(x){\n\tif (x instanceof Action) return x\n\tif (typeof x == 'function') return new Action(x)\n\tif (x.pins == null) x.pins = {}\n\tif (x.on == null) x.on = Action.prototype.on\n\tif (x.then == null) x.then = Action.prototype.then\n\tif (x.pin == null) x.pin = Action.prototype.pin\n\tif (x.dispatch == null) x.dispatch = Action.prototype.dispatch\n\treturn x\n}\n\n// set exports\nmodule.exports = function(fn){\n\treturn new Action(fn || forward)\n}\n\nfunction forward(){\n\tthis.stdout.apply(this, arguments)\n}\n\nmodule.exports.Action = Action\nmodule.exports.toAction = toAction\nmodule.exports.parseConnection = parseConnection\n\n// aliases\nAction.prototype.connect = Action.prototype.then\n",
	  "/node_modules/github.com/jkroso/keycode/tarball/0.1.0/index.js": "/**\n * Conenience method returns corresponding value for given keyName or keyCode.\n *\n * @param {Mixed} keyCode {Number} or keyName {String}\n * @return {Mixed}\n * @api public\n */\n\nexports = module.exports = function (k) {\n  if (typeof k === 'string') return codes[k.toLowerCase()]\n  return names[k]\n}\n\n/**\n * Get by name\n *\n *   exports.code['Enter'] // => 13\n */\n\nvar codes = exports.codes = {\n  'backspace': 8,\n  'tab': 9,\n  'enter': 13,\n  'shift': 16,\n  'ctrl': 17,\n  'alt': 18,\n  'pause/break': 19,\n  'caps lock': 20,\n  'esc': 27,\n  'space': 32,\n  'page up': 33,\n  'page down': 34,\n  'end': 35,\n  'home': 36,\n  'left': 37,\n  'up': 38,\n  'right': 39,\n  'down': 40,\n  'insert': 45,\n  'delete': 46,\n  'super': 91,\n  'right click': 93,\n  'numpad *': 106,\n  'numpad +': 107,\n  'numpad -': 109,\n  'numpad .': 110,\n  'numpad /': 111,\n  'num lock': 144,\n  'scroll lock': 145,\n  'my computer': 182,\n  'my calculator': 183,\n  ';': 186,\n  '=': 187,\n  ',': 188,\n  '-': 189,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '[': 219,\n  '\\\\': 220,\n  ']': 221,\n  '\\'': 222\n}\n\n/*!\n * Programatically add the rest\n */\n\nfor (var i = 48; i < 58; i++) codes[i - 48] = i\n// 0: 48\n// 1: 49\n// 2: 50\n// 3: 51\n// 4: 52\n// 5: 53\n// 6: 54\n// 7: 55\n// 8: 56\n// 9: 57\nfor (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32\n// a: 65\n// b: 66\n// c: 67\n// d: 68\n// e: 69\n// f: 70\n// g: 71\n// h: 72\n// i: 73\n// j: 74\n// k: 75\n// l: 76\n// m: 77\n// n: 78\n// o: 79\n// p: 80\n// q: 81\n// r: 82\n// s: 83\n// t: 84\n// u: 85\n// v: 86\n// w: 87\n// x: 88\n// y: 89\n// z: 90\nfor (i = 1; i < 13; i++) codes['f'+i] = i + 111\n// f1: 112\n// f2: 113\n// f3: 114\n// f4: 115\n// f5: 116\n// f6: 117\n// f7: 118\n// f8: 119\n// f9: 120\n// f10: 121\n// f11: 122\n// f12: 123\nfor (i = 0; i < 10; i++) codes['numpad '+i] = i + 96\n// numpad 0: 96\n// numpad 1: 97\n// numpad 2: 98\n// numpad 3: 99\n// numpad 4: 100\n// numpad 5: 101\n// numpad 6: 102\n// numpad 7: 103\n// numpad 8: 104\n// numpad 9: 105\n\n/**\n * Get by code\n *\n *   exports.name[13] // => 'Enter'\n */\n\nvar names = exports.names = {}\n\n// reverse mapping\nfor (i in codes) names[codes[i]] = i\n",
	  "/node_modules/github.com/component/inherit/tarball/0.0.2/index.js": "\nmodule.exports = function(a, b){\n  var fn = function(){};\n  fn.prototype = b.prototype;\n  a.prototype = new fn;\n  a.prototype.constructor = a;\n};",
	  "/presenter/src/base.js": "\nvar DomEmitter = require('dom-emitter')\n\t, ChildList = require('./childlist')\n\t, action = require('action')\n\t, Action = action.Action\n\t, classlist = require('classes')\n\t, domify = require('domify')\n\t, matches = require('matches-selector')\n\t, event = require('event')\n\t, dev = require('dev')\n\nmodule.exports = Presenter\n\n/**\n * Presenter\n * \n * If `view` is a string it will \n * be converted to a HTML DOM element\n *\n * @param {String|Element} view\n */\n\nfunction Presenter(view){\n\tif (typeof view == 'string') view = domify(view)\n\tthis.view = view\n\tthis.kids =\n\tthis.children = new ChildList(view, this)\n\tthis.classes = \n\tthis.classList = classlist(view)\n\tthis.events = new DomEmitter(view, this)\n\tthis.actions = {}\n\tdev(view, this)\n}\n\n/**\n * hook an action to a DOM event. If you omit `hook`\n * `fn.name` will be used as the DOM event hook\n *\n *   pres.action(function click(domEvent, presenter){\n *     // this === Action\n *   })\n *   // equivalent to\n *   pres.action('click', function(e, subj){})\n *\n * @param {String} [hook]\n * @param {Function|Action} act\n * @return {Action}\n */\n\nPresenter.prototype.action = function(hook, act){\n\tif (!act) act = hook, hook = act.name\n\tvar con = action.parseConnection(hook)\n\tcon.action = action.toAction(act)\n\tvar dispatch = this.actions[con.from]\n\tif (dispatch) dispatch.out = dispatch.out.concat(con)\n\telse {\n\t\tvar self = this\n\t\tdispatch = function multi(e){\n\t\t\tvar out = multi.out\n\t\t\tfor (var i = 0, len = out.length; i < len; i++) {\n\t\t\t\tvar con = out[i]\n\t\t\t\tcon.action[con.to](e, self, this)\n\t\t\t}\n\t\t}\n\t\tdispatch.out = [con]\n\t\tthis.actions[con.from] = dispatch\n\t\tevent.bind(this.view, con.from, dispatch)\n\t}\n\t\n\treturn con.action \n}\n\n/**\n * use a plugin\n *\n * @param {Function} plugin\n * @return {Any} plugin.return\n */\n\nPresenter.prototype.use = function(plugin){\n\treturn plugin(this)\n}\n\n/**\n * Insert `this` as the `prevSibling` of `sib`\n *\n * @param {Presenter} sib\n */\n\nPresenter.prototype.insertBefore = function(sib){\n\tthis.parent = sib.parent\n\tvar prev = sib.prevSibling\n\tif (prev) prev.nextSibling = this\n\tsib.prevSibling = this\n\tthis.nextSibling = sib\n\tthis.prevSibling = prev\n\n\tsib.view.parentNode.insertBefore(this.view, sib.view)\n}\n\n/**\n * Insert `this` as the `nextSibling` of `sib`\n * \n * @param {Presenter} sib\n */\n\nPresenter.prototype.insertAfter = function(sib){\n\tthis.parent = sib.parent\n\n\tvar next = sib.nextSibling\n\tthis.nextSibling = next\n\tif (next) next.prevSibling = this\n\tsib.nextSibling = this\n\tthis.prevSibling = sib\n\n\tsib.view.parentNode.insertBefore(this.view, sib.view.nextSibling)\n}\n\n/**\n * Get a list of siblings in DOM order\n *\n * @param {Boolean} inc to include `this` in the list\n * @return {Array}\n */\n\nPresenter.prototype.siblings = function(inc){\n\tvar sibs = prevSibs(this.prevSibling)\n\tinc && sibs.push(this)\n\tvar sib = this.nextSibling\n\twhile (sib) {\n\t\tsibs.push(sib)\n\t\tsib = sib.nextSibling\n\t}\n\treturn sibs\n}\n\nfunction prevSibs (view) {\n\tif (!view) return []\n\tvar prev = prevSibs(view.prevSibling)\n\tprev.push(view)\n\treturn prev\n}\n\n/**\n * Remove a view from the DOM\n * \n * @emits \"remove\"\n */\n \nPresenter.prototype.remove = function(){\n\tvar parent = this.view.parentNode\n\tif (parent) {\n\t\tthis.events.emit('remove')\n\t\tparent.removeChild(this.view)\n\t}\n}\n\n/**\n * Find the first parent matching `sel`\n *\n * @param {String} sel\n * @return {Presenter}\n */\n\nPresenter.prototype.up = function(sel){\n\tvar parent = this\n\twhile (parent = parent.parent) {\n\t\tif (matches(parent.view, sel)) return parent\n\t}\n}\n\n/**\n * Find the closest child matching `sel`.\n * The search is run breadth first.\n *\n * @param {String} sel\n * @return {Presenter}\n */\n\nPresenter.prototype.down = function(sel){\n\tvar childs = this.children.toArray()\n\tfor (var i = 0; i < childs.length; i++) {\n\t\tvar child = childs[i]\n\t\tif (matches(child.view, sel)) return child\n\t\tchild.children.each(push)\n\t}\n\n\tfunction push(child){\n\t\tchilds.push(child)\n\t}\n}\n\n/**\n * Works like `.down` except later siblings are prefered\n *\n * @param {String} sel\n * @return {Presenter}\n */\n\nPresenter.prototype.downLast = function(sel){\n\tvar childs = this.children.toArray().reverse()\n\tfor (var i = 0; i < childs.length; i++) {\n\t\tvar child = childs[i]\n\t\tif (matches(child.view, sel)) return child\n\t\treversePush(child.children.last)\n\t}\n\n\tfunction reversePush(child){\n\t\twhile (child) {\n\t\t\tchilds.push(child)\n\t\t\tchild = child.prevSibling\n\t\t}\n\t}\n}\n",
	  "/presenter/src/childlist.js": "\nmodule.exports = ChildList\n\n/**\n * Manage a list of sibling presenters\n *\n * @param {DOMElement} el\n * @param {Presenter} owner\n */\n\nfunction ChildList (el, owner) {\n\tthis.el = el\n  this.owner = owner\n}\n\n// default properties\nChildList.prototype.last = null\nChildList.prototype.first = null\n\n/**\n * Insert `child` as the `firstChild` of `this`\n *\n * @param {Presenter} child\n * @return {this}\n */\n\nChildList.prototype.append = function (child) {\n  child.parent = this.owner\n  var last = this.last\n  if (last) last.nextSibling = child\n  child.prevSibling = last\n  this.last = child\n  if (!this.first) this.first = child\n\n  this.el.appendChild(child.view)\n  return this\n}\n\n/**\n * Insert `child` as the `lastChild` of `this`\n * \n * @param {Presenter} child\n * @return {this}\n */\n\nChildList.prototype.prepend = function (child) {\n  child.parent = this.owner\n  var first = this.first\n  if (first) first.prevSibling = child\n  child.nextSibling = first\n  this.first = child\n  if (!this.last) this.last = child\n\n  this.el.insertBefore(child.view, this.el.firstChild)\n  return this\n}\n\n/**\n * produce `this` as an `Array`\n * \n * @return {Array}\n */\n\nChildList.prototype.toArray = function () {\n  var child = this.first\n  var res = []\n  while (child) {\n    res.push(child)\n    child = child.nextSibling\n  }\n  return res\n}\n\n/**\n * apply `fn` to each item in `this`\n *\n * @param {Function} fn\n * @return {this}\n */\n\nChildList.prototype.each = function (fn) {\n\tvar child = this.first\n\twhile (child) {\n\t\tfn(child)\n    child = child.nextSibling\n\t}\n\treturn this\n}\n",
	  "/node_modules/github.com/jkroso/graph/tarball/0.1.1/index.js": "\nvar toposort = require('toposort')\n\n/**\n * graph\n *\n * @param {Object} graph\n * @return {Function}\n */\n\nmodule.exports = function(graph){\n\tvar deps = toposort(makeEdges(graph))\n\treturn compile(graph, deps.reverse())\n}\n\n/**\n * compile to a function that computes each value of \n * the graph in the order specified by toposort\n * \n * @param {Object} graph\n * @param {Array} deps\n * @return {Function}\n */\n\nfunction compile(graph, deps){\n\tvar src = ''\n\tvar input = []\n\tvar last = ''\n\tdeps.forEach(function(dep){\n\t\tif (dep in graph) {\n\t\t\tvar fn = graph[dep].toString()\n\t\t\tvar params = fn.match(/\\((.*)\\)/)[1]\n\t\t\tif (usesThis(fn)) {\n\t\t\t\tsrc += '  var '+dep+' = $'+dep+'.call(this'\n\t\t\t\tif ((/\\w/).test(params)) {\n\t\t\t\t\tsrc += ',' + params\n\t\t\t\t}\n\t\t\t\tsrc += ')\\n'\n\t\t\t} else {\n\t\t\t\tsrc += '  var '+dep+' = $'+dep+'('+params+')\\n'\n\t\t\t}\n\t\t\tlast = dep\n\t\t} else {\n\t\t\tinput.unshift(dep)\n\t\t}\n\t})\n\tsrc += '  return '+last+'\\n'\n\tsrc = 'function('+input.join()+'){\\n'+src+'}'\n\treturn eval(vars(graph) + '('+src+')')\n}\n\nfunction usesThis(fn){\n\treturn (/\\bthis\\b/).test(fn)\n}\n\n/**\n * make graph keys accessable as variables\n * \n * @param {Object} graph\n * @return {String}\n */\n\nfunction vars(graph){\n\tvar src = ''\n\tfor (var p in graph) {\n\t\tsrc += 'var $'+p+' = graph[\"'+p+'\"];\\n'\n\t}\n\treturn src\n}\n\n/**\n * generate edges that toposort understands\n * \n * @param {Object} graph\n * @return {Array}\n */\n\nfunction makeEdges(graph){\n\tvar edges = []\n\tfor (var p in graph) {\n\t\tparams(graph[p]).forEach(function(dep){\n\t\t\tedges.push([p, dep])\n\t\t})\n\t}\n\treturn edges\n}\n\n/**\n * extract a functions parameter list\n * \n * @param {Function} fn\n * @return {Array}\n */\n\nfunction params(fn){\n\treturn fn.toString()\n\t\t.match(/\\((.*)\\)/)[1]\n\t\t.split(/ *, */)\n}\n",
	  "/node_modules/github.com/jkroso/clone/tarball/0.1.2/index.js": "\n/**\n * Module dependencies.\n */\n\nvar type = require('type')\n  , create = require('./create')\n\n/**\n * Clones objects.\n *\n * @param {Mixed} any object\n * @api public\n */\n\nmodule.exports = function(obj){\n  return clone(obj, [], []);\n}\n\nfunction clone(obj, seen, copies){\n  var fn = clone[type(obj)];\n  return fn ? fn(obj, seen, copies) : obj;\n}\n\nclone.object = function(a, seen, copies){\n  var k = seen.indexOf(a);\n  if (k >= 0) return copies[k];\n  var copy = create(a);\n  copies.push(copy);\n  seen.push(a);\n  for (var k in a) {\n    copy[k] = clone(a[k], seen, copies);\n  }\n  return copy\n}\n\nclone.array = function(a, seen, copies){\n  var i = seen.indexOf(a);\n  if (i >= 0) return copies[i];\n  var copy = new Array(i = a.length);\n  seen.push(a);\n  copies.push(copy);\n  while (i--) {\n    copy[i] = clone(a[i], seen, copies);\n  }\n  return copy;\n}\n\nclone.regexp = function(a){\n  var flags = ''\n    + (a.multiline ? 'm' : '')\n    + (a.global ? 'g' : '')\n    + (a.ignoreCase ? 'i' : '')\n  return new RegExp(a.source, flags);\n}\n\nclone.date = function(a){\n  return new Date(a.getTime());\n}\n\nclone.string = unbox\nclone.number = unbox\nclone.boolean = unbox\n\nfunction unbox(a){ return a.valueOf() }\n\n/**\n * Clone `clone`.\n * \n * @return {Function}\n * @api public\n */\n\nmodule.exports.self = function(){\n  var module = clone\n  for (var k in clone) {\n    module += '\\nclone.'+k+' = '+clone[k]\n  }\n  module = eval(module+';clone')\n  return function(obj){\n    return module(obj, [], [])\n  }\n}\n",
	  "/node_modules/github.com/jkroso/dom-emitter/tarball/0.5.5/index.js": "\nvar event = require('event')\n  , unique = require('unique-selector')\n  , domEvent = require('dom-event')\n\nmodule.exports = DomEmitter\n\n/**\n * Initialize a `DomEmitter`. If you provide a `context`\n * then that will be the source of implies methods. It \n * will also be `this` inside handlers.\n *\n *   new DomEmitter(document.body, {\n *     onClick: console.log  \n *   })\n *   \n * @param {DomElement} view\n * @param {Object} [context] defaults to `view`\n */\n\nfunction DomEmitter(view, context) {\n\tthis.view = view\n\tthis.context = context || view\n\tthis.domBindings = {}\n\tthis.behaviours = {}\n}\n\n/**\n * Bind to `type` with optional `method`. When `method` is \n * undefined it inferred from `type`. Delegation is can be\n * specified in `type`\n *\n *    events.on('click', 'onClick')\n *    events.on('click') // implies \"onClick\"\n *    events.on('click', function (e) {})\n *    events.on('click .ok') // delegates to `.ok`\n *\n * @param {String} type\n * @param {String} [method]\n * @return {Function} acts as a key to remove the behavior\n */\n\nDomEmitter.prototype.on = function(type, method){\n\tif (typeof type == 'object') return bindAll(this, type)\n\tvar parsed = parse(type)\n\tvar name = parsed.name\n\tvar binding = this.domBindings[name]\n\n\tif (typeof method != 'function') {\n\t\tmethod = getMethod(method, name, this.context)\n\t}\n\n\t// bind to the dom\n\tif (!binding) {\n\t\tvar path = unique(this.view) + ' '\n\t\tvar context = this.context\n\t\tvar behaviours = this.behaviours\n\n\t\tbinding = this.domBindings[name] = function dispatcher(e){\n\t\t\t// main\n\t\t\temit(context, behaviours[name], e)\n\t\t\t\n\t\t\t// delegated\n\t\t\tvar selectors = dispatcher.selectors\n\t\t\tvar len = selectors.length\n\t\t\tif (!len || e.target === this) return\n\t\t\tif (!(document.querySelector(path) === this && /^(?:#|BODY)/.test(path))) {\n\t\t\t\tpath = unique(this) + ' '\n\t\t\t}\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar targ = match(this, e.target, path + selectors[i])\n\t\t\t\tif (targ) {\n\t\t\t\t\te.delegate = targ\n\t\t\t\t\temit(context, behaviours[name+' '+selectors[i]], e)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbinding.deps = 0\n\t\tbinding.selectors = []\n\t\tevent.bind(this.view, name, binding)\n\t}\n\n\t// count\n\tbinding.deps++\n\t\n\tif (parsed.selector) {\n\t\tbinding.selectors = binding.selectors.concat(parsed.selector)\n\t}\n\n\taddBehavior(this.behaviours, type, method)\n\n\treturn method\n}\n\n/**\n * bind several functions\n *\n * @param {DomEmitter} self\n * @param {Object} events\n * @api private\n */\n\nfunction bindAll(self, events){\n\tfor (var event in events) {\n\t\tvar fn = events[event]\n\t\tif (typeof fn != 'function') {\n\t\t\tthrow new Error(event+' not a function')\n\t\t}\n\t\tself.on(event, fn)\n\t}\n}\n\n/**\n * lookup an events implied method in the `context` object\n * \n * @param {String} [name]\n * @param {String} type\n * @param {Object} context\n * @api private\n */\n\nfunction getMethod (name, type, context) {\n\tname = typeof name === 'string'\n\t\t? context[name]\n\t\t: context['on' + type[0].toUpperCase() + type.slice(1)]\n\tif (!name) throw new Error('Can\\'t find a method for '+type)\n\treturn name\n}\n\nfunction emit (context, handlers, data) {\n\tif (!handlers) return \n\tfor (var i = 0, len = handlers.length; i < len; i++) {\n\t\thandlers[i].call(context, data)\n\t}\n}\n\nfunction addBehavior (hash, name, fn) {\n\tif (hash[name]) hash[name] = hash[name].concat(fn)\n\telse hash[name] = [fn]\n}\n\nfunction removeBehaviour (hash, name, fn) {\n\tif (hash[name]) {\n\t\thash[name] = hash[name].filter(function (a) {\n\t\t\treturn a !== fn\n\t\t})\n\t\tif (hash[name].length) return\n\t}\n\tdelete hash[name]\n}\n\n/**\n * Return the first Element between `bottom` and \n * `top` that matches the selector\n *\n * @param {Element} top\n * @param {Element} bottom\n * @param {String} selector\n * @return {Element}\n * @api private\n */\n\nfunction match (top, bottom, selector) {\n\tvar nodes = top.querySelectorAll(selector)\n\tvar len = nodes.length\n\n\twhile (bottom && bottom !== top) {\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tif (nodes[i] === bottom) return bottom\n\t\t}\n\t\tbottom = bottom.parentElement\n\t}\n}\n\n/**\n * Remove a single behavior\n * \n * All the following are equivalent:\n *\n *   events.off('click', 'onClick')\n *   events.off('click') // implies 'onClick'\n *   events.off('click', events.onClick)\n *\n * @param {String} type\n * @param {String} [method]\n */\n\nDomEmitter.prototype.off = function(type, method){\n\tif (typeof type == 'object') {\n\t\tfor (var name in type) {\n\t\t\tthis.off(name, type[name])\n\t\t}\n\t\treturn this\n\t}\n\n\tvar parsed = parse(type)\n\tvar name = parsed.name\n\tvar binding = this.domBindings[name]\n\n\tif (typeof method != 'function') {\n\t\tmethod = getMethod(method, name, this.context)\n\t}\n\n\tif (--binding.deps <= 0) {\n\t\tdelete this.domBindings[name]\n\t\tevent.unbind(this.view, name, binding)\n\t} \n\telse if (parsed.selector) {\n\t\tbinding.selectors = binding.selectors.filter(function (s) {\n\t\t\treturn s !== parsed.selector\n\t\t})\n\t}\n\n\tremoveBehaviour(this.behaviours, type, method)\n}\n\n/**\n * Add listener but remove it after one call\n * @see DomEmitter#on\n */\n\nDomEmitter.prototype.once = function (topic, method) {\n\tvar self = this\n\tthis.on(topic, once)\n\tif (typeof method != 'function') {\n\t\tmethod = getMethod(method, parse(topic).name, this.context)\n\t}\n\tfunction once (e) {\n\t\tmethod.call(this, e)\n\t\tself.off(topic, once)\n\t}\n\treturn once\n}\n\n/**\n * Create a DOM event and send it down to the DomEmitter's \n * target. Any data you pass will be merged with the event \n * object\n *\n *   manager.emit('mousedown')\n *   manager.emit('login', {user: user})\n *   manager.emit('keydown', {key: 'enter'})\n * \n * @param {String} topic\n * @param {Any} [data]\n */\n\nDomEmitter.prototype.emit = function (topic, data) {\n\tvar event = domEvent(topic, data)\n\n\t// fast merge \n\tif (data) {\n\t\tvar keys = Object.keys(data)\n\t\tvar i = keys.length\n\t\twhile (i--) {\n\t\t\tvar key = keys[i]\n\t\t\tevent[key] = data[key]\n\t\t}\n\t}\n\n\tthis.view.dispatchEvent(event)\n}\n\n/**\n * Remove all bound functions.\n * Optionally limited to a certain topic\n *\n *   this.clear() // all\n *   this.clear('click') // just click handlers\n *\n * @param {String} [topic]\n */\n\nDomEmitter.prototype.clear = function (topic) {\n\tif (topic != null) return clearTopic(this, topic)\n\tfor (topic in this.behaviours) {\n\t\tclearTopic(this, topic)\n\t}\n}\n\nfunction clearTopic (self, topic) {\n\tvar name = parse(topic).name\n\tvar binding = self.domBindings[name]\n\n\tbinding && event.unbind(self.view, binding);\n\n\tdelete self.domBindings[name];\n\tdelete self.behaviours[topic];\n}\n\n/**\n * Parse event / selector string.\n *\n * @param {String} string\n * @return {Object}\n * @api private\n */\n\nfunction parse(str) {\n\tstr = str.split(' ')\n\tvar event = str.shift()\n\treturn { name: event, selector: str.join(' ') }\n}\n",
	  "/node_modules/github.com/component/classes/tarball/1.1.0/index.js": "\n/**\n * Module dependencies.\n */\n\nvar index = require('indexof');\n\n/**\n * Whitespace regexp.\n */\n\nvar re = /\\s+/;\n\n/**\n * toString reference.\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Wrap `el` in a `ClassList`.\n *\n * @param {Element} el\n * @return {ClassList}\n * @api public\n */\n\nmodule.exports = function(el){\n  return new ClassList(el);\n};\n\n/**\n * Initialize a new ClassList for `el`.\n *\n * @param {Element} el\n * @api private\n */\n\nfunction ClassList(el) {\n  this.el = el;\n  this.list = el.classList;\n}\n\n/**\n * Add class `name` if not already present.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.add = function(name){\n  // classList\n  if (this.list) {\n    this.list.add(name);\n    return this;\n  }\n\n  // fallback\n  var arr = this.array();\n  var i = index(arr, name);\n  if (!~i) arr.push(name);\n  this.el.className = arr.join(' ');\n  return this;\n};\n\n/**\n * Remove class `name` when present, or\n * pass a regular expression to remove\n * any which match.\n *\n * @param {String|RegExp} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.remove = function(name){\n  if ('[object RegExp]' == toString.call(name)) {\n    return this.removeMatching(name);\n  }\n\n  // classList\n  if (this.list) {\n    this.list.remove(name);\n    return this;\n  }\n\n  // fallback\n  var arr = this.array();\n  var i = index(arr, name);\n  if (~i) arr.splice(i, 1);\n  this.el.className = arr.join(' ');\n  return this;\n};\n\n/**\n * Remove all classes matching `re`.\n *\n * @param {RegExp} re\n * @return {ClassList}\n * @api private\n */\n\nClassList.prototype.removeMatching = function(re){\n  var arr = this.array();\n  for (var i = 0; i < arr.length; i++) {\n    if (re.test(arr[i])) {\n      this.remove(arr[i]);\n    }\n  }\n  return this;\n};\n\n/**\n * Toggle class `name`.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.toggle = function(name){\n  // classList\n  if (this.list) {\n    this.list.toggle(name);\n    return this;\n  }\n\n  // fallback\n  if (this.has(name)) {\n    this.remove(name);\n  } else {\n    this.add(name);\n  }\n  return this;\n};\n\n/**\n * Return an array of classes.\n *\n * @return {Array}\n * @api public\n */\n\nClassList.prototype.array = function(){\n  var arr = this.el.className.split(re);\n  if ('' === arr[0]) arr.pop();\n  return arr;\n};\n\n/**\n * Check if class `name` is present.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.has =\nClassList.prototype.contains = function(name){\n  return this.list\n    ? this.list.contains(name)\n    : !! ~index(this.array(), name);\n};\n",
	  "/node_modules/github.com/jkroso/domify/tarball/0.1.1/index.js": "var slice = require('sliced')\n\nmodule.exports = parse\n\n/**\n * Wrap map from jquery.\n */\n\nvar map = {\n  option: [1, '<select multiple=\"multiple\">', '</select>'],\n  optgroup: [1, '<select multiple=\"multiple\">', '</select>'],\n  legend: [1, '<fieldset>', '</fieldset>'],\n  thead: [1, '<table>', '</table>'],\n  tbody: [1, '<table>', '</table>'],\n  tfoot: [1, '<table>', '</table>'],\n  colgroup: [1, '<table>', '</table>'],\n  caption: [1, '<table>', '</table>'],\n  tr: [2, '<table><tbody>', '</tbody></table>'],\n  td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\n  th: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\n  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],\n  _default: [0, '', '']\n};\n\nvar div = document.createElement('div')\n  , tagregex = /<([\\w:]+)/\n\n/**\n * Parse `html` and return the Element's it generates.\n *\n * @param {String} html\n * @return {Array|Element}\n */\n\nfunction parse(html) {\n  if ('string' != typeof html) throw new TypeError('String expected');\n  \n  // tag name\n  var m = html.match(tagregex)\n  if (!m) return document.createTextNode(html)\n  var tag = m[1];\n  \n  // body support\n  if (tag == 'body') {\n    var el = document.createElement('html');\n    el.innerHTML = html;\n    return el.removeChild(el.lastChild)\n  }\n  \n  // wrap so the browser isn't forced do anything clever\n  var wrap = map[tag] || map._default;\n  var depth = wrap[0];\n  var prefix = wrap[1];\n  var suffix = wrap[2];\n  div.innerHTML = prefix + html + suffix;\n  var el = div\n  while (depth--) el = el.lastChild;\n\n  html = el.childNodes\n  html = html.length > 1 ? slice(html) : html[0];\n  // clear the parent so the new dom elements don't have an incorrect parentElement\n  el.innerHTML = ''\n  return html\n}\n\n/**\n * A version of domify which always returns an Array\n * Its handy in cases where you don't know much about\n * the html you are inputing\n *\n * @param {String} html\n * @return {Array}\n */\n\nparse.all =\nparse.list =\nparse.array = function (html) {\n  html = parse(html)\n  return html instanceof Array ? html : [html]\n}\n",
	  "/node_modules/github.com/jkroso/matches-selector/tarball/0.1.1/index.js": "\n/**\n * Element prototype.\n */\n\nvar proto = Element.prototype;\n\n/**\n * Vendor function.\n */\n\nvar vendor = proto.matchesSelector\n  || proto.webkitMatchesSelector\n  || proto.mozMatchesSelector\n  || proto.msMatchesSelector\n  || proto.oMatchesSelector;\n\n/**\n * Expose `match()`.\n */\n\nmodule.exports = vendor \n  ? match\n  // Fallback for IE8 etc..\n  : function match (el, selector) {\n    var parent = el.parentNode, frag\n\n    // use a DocumentFragment if the node isn't part of any other DOM node\n    if (!parent) {\n      parent = frag = document.createDocumentFragment();\n      frag.appendChild(el);\n    }\n\n    var nodes = parent.querySelectorAll(selector)\n      , i = nodes.length\n    while (i--) {\n      if (nodes[i] === el) {\n        // detach from DocumentFragment if we used one\n        if (frag) frag.removeChild(frag.lastChild)\n        return true\n      }\n    }\n\n    return false\n  } \n\n/**\n * Match `el` to `selector`.\n *\n * @param {Element} el\n * @param {String} selector\n * @return {Boolean}\n * @api public\n */\n\nfunction match(el, selector) {\n  return vendor.call(el, selector);\n}",
	  "/node_modules/github.com/component/event/tarball/0.1.0/index.js": "\n/**\n * Bind `el` event `type` to `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.bind = function(el, type, fn, capture){\n  if (el.addEventListener) {\n    el.addEventListener(type, fn, capture);\n  } else {\n    el.attachEvent('on' + type, fn);\n  }\n  return fn;\n};\n\n/**\n * Unbind `el` event `type`'s callback `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.unbind = function(el, type, fn, capture){\n  if (el.removeEventListener) {\n    el.removeEventListener(type, fn, capture);\n  } else {\n    el.detachEvent('on' + type, fn);\n  }\n  return fn;\n};\n",
	  "/node_modules/github.com/component/dev/tarball/master/index.js": "\n/**\n * Enabled flag.\n */\n\nvar enabled = window.localStorage && window.localStorage.dev;\n\n// noop\n\nif (!enabled) {\n  module.exports = function(){};\n  return;\n}\n\n/**\n * Map `obj` to `el` for inspection with `name` or \"_\".\n *\n * @param {Element|jQuery|Number} el\n * @param {Object} obj\n * @param {String} name\n * @api public\n */\n\nmodule.exports = function(el, obj, name){\n  name = name || '_';\n  if (!el) throw new TypeError('element required');\n  el = el[0] || el;\n  el[name] = obj;\n  el.setAttribute('inspectable', '');\n};\n",
	  "/node_modules/github.com/jkroso/clone/tarball/0.1.2/create.js": "\n/**\n * a minimal Object.create() shim\n */\n\nmodule.exports = Object.create\n\nif (!module.exports) {\n\tfunction C(){}\n\tmodule.exports = function(a){\n\t\tC.prototype = a;\n\t\treturn new C;\n\t}\n}\n",
	  "/node_modules/github.com/jkroso/type/tarball/1.0.1/index.js": "\n/**\n * refs\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Return the type of `val`.\n *\n * @param {Mixed} val\n * @return {String}\n * @api public\n */\n\nmodule.exports = function(v){\n  // .toString() is slow so try avoid it\n  return typeof v === 'object'\n    ? types[toString.call(v)]\n    : typeof v\n};\n\nvar types = {\n  '[object Function]': 'function',\n  '[object Date]': 'date',\n  '[object RegExp]': 'regexp',\n  '[object Arguments]': 'arguments',\n  '[object Array]': 'array',\n  '[object String]': 'string',\n  '[object Null]': 'null',\n  '[object Undefined]': 'undefined',\n  '[object Number]': 'number',\n  '[object Boolean]': 'boolean',\n  '[object Object]': 'object',\n  '[object Text]': 'textnode',\n  '[object Uint8Array]': '8bit-array',\n  '[object Uint16Array]': '16bit-array',\n  '[object Uint32Array]': '32bit-array',\n  '[object Uint8ClampedArray]': '8bit-array',\n  '[object Error]': 'error'\n}\n\nif (typeof window != 'undefined') {\n  for (var el in window) if (/^HTML\\w+Element$/.test(el)) {\n    types['[object '+el+']'] = 'element'\n  }\n}\n\nmodule.exports.types = types\n",
	  "/node_modules/github.com/marcelklehr/toposort/tarball/0.2.9/index.js": "\nmodule.exports = toposort;\n\n/**\n * Topological sorting function\n * \n * @param {Array} edges\n * @returns {Array}\n */\n\nfunction toposort(edges) {\n   var nodes = uniqueNodes(edges)\n     , index = nodes.length\n     , sorted = new Array(index)\n\n  while (index) visit(nodes[0], [])\n\n  return sorted\n\n  function visit(node, predecessors) {\n    if(predecessors.indexOf(node) >= 0) {\n      throw new Error('Cyclic dependency: '+JSON.stringify(node))\n    }\n\n    var i = nodes.indexOf(node)\n    \n    // already visited\n    if (i < 0) return;\n\n    nodes.splice(i, 1)\n\n    // outgoing edges\n    var out = edges.filter(function(edge){\n      return edge[0] === node\n    })\n    if (i = out.length) {\n      var preds = predecessors.concat(node)\n      do {\n        visit(out[--i][1], preds)\n      } while (i)\n    }\n    \n    sorted[--index] = node\n  }\n}\n\nfunction uniqueNodes(arr){\n  var res = []\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var edge = arr[i]\n    if (res.indexOf(edge[0]) < 0) res.push(edge[0])\n    if (res.indexOf(edge[1]) < 0) res.push(edge[1])\n  }\n  return res\n}\n",
	  "/node_modules/github.com/jkroso/unique-selector/tarball/0.0.2/index.js": "/**\n * Expose `unique`\n */\n\nmodule.exports = unique;\n\n/**\n * Generate unique CSS selector for given DOM element\n *\n * @param {Element} el\n * @return {String}\n * @api private\n */\n\nfunction unique(el) {\n  if (!el || !el.tagName) {\n    throw new TypeError('Element expected');\n  }\n\n  if (el === document) return 'HTML'\n\n  return selector(el)\n}\n\n/**\n * Build a selector string\n *\n * @param {Element} el\n * @return {String}\n * @api prviate\n */\n\nfunction selector(el) {\n  var selector = ''\n  var body = document.body\n\n  do {\n    // IDs are unique enough\n    if (el.id) {\n      return '#' + el.id + (selector && ('>' + selector));\n    }\n    if (el === body) {\n      return 'BODY'+ (selector && ('>' + selector));\n    }\n\n    var label = el.tagName\n    // avoid documents\n    if (!label) return selector\n    var className = el.getAttribute('class');\n\n    if (className) {\n      label += '.' + className.replace(/ /g, '.');\n    }\n\n    label += ':nth-child(' + index(el) +')';\n    selector = label + (selector && ('>' + selector));\n\n  } while (el = el.parentNode);\n\n  return selector\n}\n\nfunction index(el){\n  var i = 1\n  while (el = el.previousElementSibling) i++;\n  return i\n}\n",
	  "/node_modules/github.com/jkroso/dom-event/tarball/0.3.1/index.js": "\nvar codes = require('keycode').codes\n  , Event = window.Event\n\n/**\n * Create a native DOM event\n *\n *   event('mousemove')\n *   event('keydown', { key: 'a' })\n *   event('user-login')\n *\n * @param {String} type\n * @param {Object} [options]\n * @return {DomEvent}\n */\n\nfunction event(type, options){\n  return (make[type] || custom)(type, options || {})\n}\n\n/*!\n * TODO: switch functions to fallbacks here\n * if we are in an old IE\n */\n\nvar make = {\n  // html\n  load: html, \n  unload: html, \n  abort: html, \n  error: html, \n  select: html, \n  change: html, \n  submit: html, \n  reset: html, \n  focus: html, \n  blur: html, \n  resize: html, \n  scroll: html, \n  input: html, \n  \n  // mouse\n  click: function(name, o){\n   'clicks' in o || (o.clicks = 1)\n    return mouse('click', o)\n  },\n  dblclick: function(name, o){\n    'clicks' in o || (o.clicks = 2)\n    return mouse('dblclick', o)\n  }, \n  mousedown: mouse, \n  mouseup: mouse, \n  mouseover: mouse, \n  mousemove: mouse, \n  mouseout: mouse,\n  contextmenu: function(name, o){\n    'button' in o || (o.button = 2)\n    return mouse('contextmenu', o)\n  },\n\n  // keyboard\n  keypress: keyboard,\n  keydown: keyboard,\n  keyup: keyboard\n}\n\n/**\n * Create a native mouse event\n *\n *   mouse('mousemove', {})\n *   mouse('mousemove', {clientX: 50, clientY: 50})\n * \n * @param {String} name\n * @param {Object} o\n * @return {MouseEvent}\n * @api private\n */\n\nfunction mouse (name, o){\n  var event = document.createEvent('MouseEvents')\n  event.initMouseEvent(\n    name,\n    o.bubbles !== false,\n    o.cancelable !== false,\n    window,\n    o.clicks,\n    o.screenX || 0,\n    o.screenY || 0,\n    o.clientX || 0,\n    o.clientY || 0,\n    o.ctrl === true,\n    o.alt === true,\n    o.shift === true,\n    o.meta === true,\n    o.button || 0,\n    o.relatedTarget\n  )\n  return event\n}\n\n/**\n * Create a html document event\n *\n *   event('blur', {})\n *   event('change', {bubbles: false})\n *\n * @param {String} name\n * @param {Object} o\n * @return {HTMLEvent}\n * @api private\n */\n\nfunction html (name, o){\n  var event = document.createEvent('HTMLEvents')\n  event.initEvent(name, \n    o.bubbles !== false, \n    o.cancelable !== false\n  )\n  return event\n}\n\n/**\n * Create a keyboard event\n *\n *   event('keypress', {\n *     key: 'enter'\n *   })\n *\n * @param {String} type\n * @param {Object} o\n * @return {KeyboardEvent}\n * @api private\n */\n\nfunction keyboard(type, o) {\n  var key = o.key || 'a'\n  var keycode = codes[key]\n  if (!keycode) throw new Error('invalid key: '+key)\n\n  var charCode = key.length === 1 \n    ? key.charCodeAt(0) \n    : 0\n\n  // Prefer custom events to avoid webkits bug \n  // https://bugs.webkit.org/show_bug.cgi?id=16735\n  if (Event) {\n    var e = custom(type, o)\n    e.keyCode = keycode\n    e.charCode = charCode\n    e.shift = o.shift === true\n    e.meta = o.meta === true\n    e.ctrl = o.ctrl === true\n    e.alt = o.alt === true\n  } else {\n    var e = document.createEvent('KeyboardEvent')\n    e[e.initKeyEvent ? 'initKeyEvent' : 'initKeyboardEvent'](\n      type,\n      o.bubbles !== false,\n      o.cancelable !== false,\n      window,\n      o.ctrl === true,\n      o.alt === true,\n      o.shift === true,\n      o.meta === true,\n      keycode,\n      charCode\n    )\n  }\n  return e\n}\n\n\n/**\n * Create a custom event\n *\n *   custom('select', {\n *     bubbles: false\n *   })\n *\n * @param {String} name\n * @param {Object} o\n * @return {Event}\n * @api private\n */\n\nfunction custom(name, o) {\n  return new Event(name, {\n    bubbles: o.bubbles !== false,\n    cancelable: o.cancelable !== false\n  })\n}\n\n/*!\n * Export event factory and helpers\n */\n\nmodule.exports = event\nevent.mouse = mouse\nevent.keyboard = keyboard\nevent.custom = custom\nevent.html = html\n",
	  "/node_modules/github.com/component/indexof/tarball/master/index.js": "\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};",
	  "/node_modules/github.com/aheckmann/sliced/tarball/master/index.js": "module.exports = exports = require('./lib/sliced');\n",
	  "/node_modules/github.com/aheckmann/sliced/tarball/master/lib/sliced.js": "\n/**\n * An Array.prototype.slice.call(arguments) alternative\n *\n * @param {Object} args something with a length\n * @param {Number} slice\n * @param {Number} sliceEnd\n * @api public\n */\n\nmodule.exports = function (args, slice, sliceEnd) {\n  var ret = [];\n  var len = args.length;\n\n  if (0 === len) return ret;\n\n  var start = slice < 0\n    ? Math.max(0, slice + len)\n    : slice || 0;\n\n  if (sliceEnd !== undefined) {\n    len = sliceEnd < 0\n      ? sliceEnd + len\n      : sliceEnd\n  }\n\n  while (len-- > start) {\n    ret[len - start] = args[len];\n  }\n\n  return ret;\n}\n\n"
	}
	var aliases = {
	  "/keydispatch/node_modules/presenter/index.js": "/presenter/index.js",
	  "/keydispatch/node_modules/action/index.js": "/node_modules/github.com/jkroso/action/tarball/0.1.0/index.js",
	  "/presenter/node_modules/action/index.js": "/node_modules/github.com/jkroso/action/tarball/0.1.0/index.js",
	  "/keydispatch/node_modules/keycode/index.js": "/node_modules/github.com/jkroso/keycode/tarball/0.1.0/index.js",
	  "/node_modules/github.com/jkroso/dom-event/tarball/0.3.1/node_modules/keycode/index.js": "/node_modules/github.com/jkroso/keycode/tarball/0.1.0/index.js",
	  "/keydispatch/node_modules/inherit/index.js": "/node_modules/github.com/component/inherit/tarball/0.0.2/index.js",
	  "/presenter/node_modules/graph/index.js": "/node_modules/github.com/jkroso/graph/tarball/0.1.1/index.js",
	  "/presenter/node_modules/clone/index.js": "/node_modules/github.com/jkroso/clone/tarball/0.1.2/index.js",
	  "/presenter/node_modules/dom-emitter/index.js": "/node_modules/github.com/jkroso/dom-emitter/tarball/0.5.5/index.js",
	  "/presenter/node_modules/classes/index.js": "/node_modules/github.com/component/classes/tarball/1.1.0/index.js",
	  "/presenter/node_modules/domify/index.js": "/node_modules/github.com/jkroso/domify/tarball/0.1.1/index.js",
	  "/presenter/node_modules/matches-selector/index.js": "/node_modules/github.com/jkroso/matches-selector/tarball/0.1.1/index.js",
	  "/presenter/node_modules/event/index.js": "/node_modules/github.com/component/event/tarball/0.1.0/index.js",
	  "/node_modules/github.com/jkroso/dom-emitter/tarball/0.5.5/node_modules/event/index.js": "/node_modules/github.com/component/event/tarball/0.1.0/index.js",
	  "/presenter/node_modules/dev/index.js": "/node_modules/github.com/component/dev/tarball/master/index.js",
	  "/node_modules/github.com/jkroso/clone/tarball/0.1.2/node_modules/type/index.js": "/node_modules/github.com/jkroso/type/tarball/1.0.1/index.js",
	  "/node_modules/github.com/jkroso/graph/tarball/0.1.1/node_modules/toposort/index.js": "/node_modules/github.com/marcelklehr/toposort/tarball/0.2.9/index.js",
	  "/node_modules/github.com/jkroso/dom-emitter/tarball/0.5.5/node_modules/unique-selector/index.js": "/node_modules/github.com/jkroso/unique-selector/tarball/0.0.2/index.js",
	  "/node_modules/github.com/jkroso/dom-emitter/tarball/0.5.5/node_modules/dom-event/index.js": "/node_modules/github.com/jkroso/dom-event/tarball/0.3.1/index.js",
	  "/node_modules/github.com/component/classes/tarball/1.1.0/node_modules/indexof/index.js": "/node_modules/github.com/component/indexof/tarball/master/index.js",
	  "/node_modules/github.com/jkroso/domify/tarball/0.1.1/node_modules/sliced/index.js": "/node_modules/github.com/aheckmann/sliced/tarball/master/index.js"
	}
		
	/**	
	 * give each module an identity	
	 */	
		
	for (var file in modules) {	
		modules[file] = {	
			source: modules[file],	
			loaded: false,	
			exports: {}	
		}	
	}	
		
	/**	
	 * add aliases to the module map	
	 */	
		
	for (var alias in aliases) {	
		if (alias in modules) continue	
		modules[alias] = modules[aliases[alias]] 	
	}	
		
	/**	
	 * Require the given path.	
	 *	
	 * @param {String} path	
	 * @param {String} parent	
	 * @return {Any} module.exports	
	 */	
		
	function require (path, parent){	
		parent || (parent = '/')	
		
		var fullpath = resolve(parent, path)	
		if (!fullpath) throw Error('failed to require '+path+' from '+parent)	
		if (fullpath in aliases) fullpath = aliases[fullpath]	
		var module = modules[fullpath]	
		
		if (!module.loaded) {	
			module.loaded = true	
			Function(	
				'module',	
				'exports',	
				'require',	
				// sourceURL tells the browser we are evaling a file	
				module.source + '\n//@ sourceURL=' + encodeURI(fullpath)	
			).call(module.exports, module, module.exports,	
				// relative `require` function	
				function(path){	
					var base = dirname(fullpath)	
					if (path[0] == '.') path = join(base, path)	
					return require(path, base)	
				}	
			)	
		}	
		return module.exports	
	}	
		
	/**	
	 * Figure out what the full path to the module is	
	 *	
	 * @param {String} base, the current directory	
	 * @param {String} path, what was inside the call to require	
	 * @return {String}	
	 * @api private	
	 */	
		
	function resolve (base, path) {	
		// absolute	
		if (/^\/|(?:\w+:\/\/)/.test(path)) {	
			return complete(path)	
		} else if (/^\./.test(path)) {	
			// todo: fix join for urls	
			return complete(join(base, path))	
		}	
		
		// walk up looking in node_modules	
		while (true) {	
			var res = complete(join(base, 'node_modules', path))	
			if (res) return res	
			if (base == '/' || base == '.') break	
			base = dirname(base)	
		}	
	}	
		
	/**	
	 * get the parent directory path	
	 *	
	 * @param {String} path	
	 * @return {String}	
	 */	
		
	function dirname(path){	
		var i = path.lastIndexOf('/')	
		if (i < 0) return '.'	
		return path.slice(0, i) || '/'	
	}	
		
	/**	
	 * Clean up a messy path	
	 *	
	 *   normalize('/foo//baz/quux/..') // => '/foo/baz'	
	 *	
	 * @param {String} path	
	 * @return {String}	
	 */	
		
	function normalize(path){	
	  var segs = path.split('/')	
	  if (segs.length <= 1) return path	
	  var res = []	
	  var up = 0	
		
	  for (var i = 0, len = segs.length; i < len; i++) {	
	    var seg = segs[i]	
	    if (seg === '' || seg === '.') continue	
	    if (seg === '..') up++, res.pop()	
	    else up--, res.push(seg)	
	  }	
		
	  if (up > 0) {	
	    if (path[0] == '/') return '/'	
	    res = '..'	
	    while (--up) res += '/..'	
	    return res	
	  }	
	  return path[0] == '/'	
	    ? '/' + res.join('/')	
	    : res.join('/') || '.'	
	}	
		
	/**	
	 * Concatenate a sequence of path segments to generate one flat path	
	 * 	
	 * @param {String} [...]	
	 * @return {String}	
	 */	
		
	function join(path){	
		for (var i = 1, len = arguments.length; i < len; i++) {	
			path += '/' + arguments[i]	
		}	
	  return normalize(path)	
	}	
		
	/**	
	 * Produce an ordered list of paths to try	
	 * 	
	 * @param {String} path	
	 * @return {Array} of path	
	 * @private	
	 */	
		
	function completions(path){	
		// A directory	
		if (path.match(/\/$/)) {	
			return [	
				path+'index.js',	
				path+'index.json',	
				path+'package.json'	
			]	
		}	
		// could be a directory or a file	
		return [	
			path,	
			path+'.js',	
			path+'.json',	
			path+'/index.js',	
			path+'/index.json',	
			path+'/package.json'	
		]	
	}	
		
	/**	
	 * find the first matching path completion	
	 *	
	 * @param {String} path	
	 * @return {String} full path of the module	
	 */	
		
	function complete(path) {	
		return completions(path).filter(function (path) {	
			return path in modules	
		})[0]	
	}	
	
	return require("/keydispatch/examples/simple.js")
})